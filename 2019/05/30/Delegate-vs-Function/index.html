<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Delegate vs Function</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script></head><body><nav class="main-nav"><a href="/">Home</a><a href="/about">About Me</a><a href="/tags">Tags</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Olive X</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>Delegate vs Function</h1><h2 class="headline">May 30, 2019 09:25<!--|·--><!--|#{wordcount(page.content)} words--><!--|·--><!--|#{min2read(page.content)} minutes read--></h2></header><section id="post-body"><p>委托的主要好处是可以把方法作为参数/属性来赋值或传递。事件是委托的一种具体应用。委托可以理解为一种接口，具体的方法实现这个接口，在开发阶段只需要关心委托的定义就可以调用，而不用关心它如何实现的或者在哪里实现的。</p>
<p>委托就是对一个方法映射，把方法名当参数来传递，类似JS中的在某个function的参数中把另一个function的名称当参数来传递。</p>
<p>//定义委托原型<br>delegate void UpdateHandler(int id);<br>//定义符合委托原型的方法UpdateMember<br>void UpdateMember(int id)<br>{<br>    //更新用户逻辑<br>}<br>//定义符合委托原型的方法DeleteMember<br>void DeleteMember(int id)<br>{<br>    //删除用户逻辑<br>}</p>
<p>如何使用呢，如下：<br>//实例化委托对象，再构造函数中把方法名当参数来传递。<br>UpdateHandler handler = new UpdateHandler(UpdateMember);<br>//执行委托对象<br>handler(某个用户id);<br>handler(某个用户id)就等价于<br>UpdateMember(某个用户id)</p>
<p>也可以连接多个相同签名的方法，组成一个委托链，当调用委托对象时，链上的方法，按映射的顺序一次被执行。</p>
<p>如何使用呢，如下：<br>UpdateHandler handler = new UpdateHandler(UpdateMember);<br>handler += DeleteMember;<br>handler(某个用户id);<br>handler(某个用户id)就等价于<br>UpdateMember(某个用户id)<br>DeleteMember(某个用户id)</p>
<p>事件的话，看看设计模式中的观察者模式。<br>被观察对象中维护了一个观察者列表，这些观察者会对被观察者某个“动作”，即事件，做出各自不同的反映。<br>常见的例子如下：<br>某一场景下有主人，猫，狗3个对象。<br>当主人“打开门”后，猫“跑开了”，狗“叫了”。<br>整个过程中，主人就是被观察对象，猫和狗都是观察者。<br>一旦主人触发“打开门”这个事件的话，猫狗做出不同的反映，猫“跑开了”，狗“叫了”。<br>代码如下：<br>public class Host<br>{<br>//定义委托原型<br>    public delegate void OpenDoorEventHandler();<br>//定义委托类型的事件<br>    public event GoHomeEventHandler OpenDoor;<br>//定义内部一个方法，在这个方法内判断，OpenDoor事件是否被其他对象注册，一旦注册了，则调用执行事件。<br>    protected void OnOpenDoor()<br>    {<br>        if(OpenDoor!=null)<br>        {<br>            OpenDoor();<br>        }<br>    }<br>    public void GoHome()<br>    {<br>        OnOpenDoor();<br>    }<br>}<br>public class Cat<br>{<br>    public void Run()<br>    {<br>        //猫跑了<br>    }<br>}<br>public class Dog<br>{<br>    public void Bark()<br>    {<br>        //狗叫了<br>    }<br>}<br>如何使用如下：<br>Host 主人 =new Host();<br>Cat 猫 = new Cat();<br>Dog 狗 = new Dog();</p>
<p>主人.OpenDoor += new 主人.OpenDoorEventHandler(猫.Run);<br>主人.OpenDoor += new 主人.OpenDoorEventHandler(狗.Back);</p>
<p>主人.GoHome就等价于<br>猫.Run();<br>狗.Back();</p>
<p>当被观察者，做出某一特定“动作”(被观察者的特定“动作”，注册了N个不同对象的不同反映)，观察者对这个特定“动作”做出不懂的反映。</p>
</section><div class="tags"><a href="/tags/Unreal-Engine/">Unreal Engine</a></div><nav id="post-nav"><span class="prev"><a href="/2019/06/03/Delegates/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2019/05/29/Why-need-PlayerState/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/Olivexicklop"><i class="fa fa-github"></i></a></div><p class="small">© Copyright 2019 &nbsp;<a href="https://github.com/ffinnocean"> <i class="fa fa-heart" aria-hidden="true">&nbsp; KK &nbsp;</i></a></p><p class="small">Powered by &nbsp;<a href="https://hexo.io/">Hexo &nbsp;</a><!--Theme By &nbsp;--><!--a(href='https://github.com/fuzhouxxdong/hexo-theme-dxx') Dxx--></p></footer><script>hljs.initHighlightingOnLoad();</script></body></html>